# 数据导出工具
简介：该工具用于将配置表数据导出成配置类代码及字节流配置数据。使用该工具必须按一定要求配置Excel表，程序将根据Excel前几行数据生成配置类。除此以外，还提供了多语言的导出工具。

### 支持的类型
        Int8,// 一字节整型
        Int16,// 两字节整型
        Int32,// 三字节整型
        Int64,// 四字节整型
        Boolean,// 布尔值
        Float,// 单精度浮点数
        Double,// 双精度浮点数
        String,// 原生字符串，不会加入翻译表的字符串
        Text,// 可翻译的字符串
        Enum,// 自定义的枚举类型，需要一张自定义的枚举类型表
        NestedClass// 自定义内嵌类
上述所有类型都可以定义成一个List列表，需要在表头某行指定是否定义为List。
List有两种类型，固定长度List和可变长List，固定长度List会在导出时检测数据的列表长度是否是指定的长度，否则会报错。
        
## 总体表结构
“第一行第一单元格”指定配置表类型，配置表类型分为枚举表和数据类表，关键词为Enum和Class.

### 枚举类型定义
对于Enum类型，“第二行”前三单元格依次为枚举名称、备注/注释、生成代码面向服务器/客户端。

枚举名称规范：1、不要和其他枚举名或数据类重名；2、首字符只允许下划线和字母，名称内可包含数字。

备注/注释：标注该枚举的含义，会在代码中为该枚举类生成注释。

生成代码面向服务器/客户端：代码面向服务器端、客户端或者双端。若部分列表字段或枚举表对服务器或客户端不可见，就设置仅客户端或服务器端可见，或双方都可见，或双方都不可见，关键词为Client，Server，Both，None。

“第三行”为枚举字段名，三列固定为ID，Value，Comment，分别表示枚举字段表示的值，名称和注释
从第四行开始，往下每行都是数据行，表明枚举的值和名称。

### 配置类类型定义
对于Class类型，“第二行第一单元格”表明类型名称，命名规范与枚举类型定义相同，“第二行第二单元格”表明类型注释，会在生成代码时作为注释生成。
从第三行开始，每一列都是一个类的字段，而每一个字段都需要十行来定义。
这十行依次是：
1、字段名；
2、字段备注/注释；
3、服务器/客户端可见性；
4、字段类型；
5、关联的外键；
6、是否是List，及List的类型；
7、内嵌类字段列表；
8、内嵌类字段注释；
9、内嵌类各字段类型；
10、内嵌类列表类型（该行应当都标记为None，支持并不完善）

**1-4数据不再赘言。下面将5-10的作用说明下。**

#### 外键关联
首先外键关联只存在于Class表中，但不论Enum表还是Class表都存在一个主键ID，该主键ID名称被限定为ID（可忽略大小写），类型也会被限制为Int32。

使用主键外键就是为了给各个数据表之间建立联系，以检查某些关联数据的安全性。比如A表某字段是引用了B表的数据，那就指定A表的该字段外键关联了B表的ID，在导出数据的时候就会检查A表该字段引用的B表数据究竟存不存在，一定程度上解决游戏运行时的配置数据异常问题。

最常见的是，Class表某字段是枚举类型的，那必定需要与一张枚举表建立联系，就要指定其外键，外键填写格式为“配置表类型.ID”或者"配置表类型.Value"的格式，其中"配置表类型.Value"仅针对枚举外键。前面有讲到，枚举表有ID列和Value列，ID列是Int32类型的枚举值，Value列则是String类型的枚举名称。但是不管枚举字段填写的是“配置表类型.ID”还是"配置表类型.Value"，都允许同时填写枚举值或枚举名称，最好填写的时候确定该列是填值还是名称，不要混着写。Class表引用另一个Class表的数据，也可以设置相应列的外键，以开启数据安全检查。

主键ID不能重复，导出数据时会对该列数据进行重复性检查。

#### 列表类型
列表类型分为非列表类型、固定长度列表和可变长度列表，数据需要用英文的分号隔开，配置的关键词分别是None、List[#number#]、List[x]，其中固定长度列表的关键词#number#需要替换成一个大于0的整型数字，以表示该列列表长度

#### 内嵌类
在字段类型的行自定义一个类型名称，导出程序将其解析为一个内嵌类型，在7-10指定该类型的各字段，各字段用英文逗号隔开，且字段名、注释、类型、列表类型一一对应。这个内嵌类的各字段类型应当是基础类型，而不是另一个内嵌类，且尽量不要列表化，主要是为了不让数据变得复杂，列表头信息后各个数据单元格里，用逗号隔开不同字段的数据。如果数组化或者是在嵌套一个内嵌类型，那字符串解析就会变复杂，看表的人看起来也会很累（绝不是我觉得麻烦，不过后续可以思考下合适的字符串解析策略，毕竟，功能可以有，用不用是另外一回事）。总之，对于配置类，内嵌类的存在并不是非常必要的，只是作为逻辑的补充。目前内嵌类也是支持数组化的。

#### 可翻译字符串
在支持的数据类型里可以看到Text类型，该类型字段是会参与翻译的，String类型则是程序用字段类型，不会参与翻译。

程序在导表时，会收集类型为Text的数据，并为每一个Text类型的数据（包括Text类型列表的每一个数据）生成一个ID，这个ID作为翻译项的ID，将会被导出到翻译表（程序生成的Excel表）中，翻译表除了头数据，每一行数据都包含ID，原始文本，翻译文本和来源信息。ID和原始文本不用多说，翻译文本是我们需要手动填写的，翻译表生成前是会先加载已经存在的翻译表的，所以不用担心再次导出时会覆盖旧的翻译文本。来源信息则是标记该翻译文本原始文本来源自哪个表哪一行哪个字段。导出程序也是以来源信息作为依据，来保证翻译项ID的稳定性，同时保留原有的翻译文本。

翻译表除了导出我们所需的那些语种翻译表，还会导出Default语种的翻译表，该类型的翻译表不必填写翻译文本，但并不代表该类型翻译表是没用的，相反，他是其他所有语种翻译表依赖的表。所有语种翻译表的翻译项都以该表为准，从Default语种的翻译项同步ID和来源信息。也就是说Default表保证了其他所有语种翻译表信息同步。不会出现各语种间同一翻译项，ID、来源信息或者翻译项数量不同步。

导表程序支持删除过期翻译项，某些翻译项的来源表因为某些原因删除了某一行或某一字段，导致翻译项失效，可以勾选面板上的自动删除过期翻译项选项，以此减少翻译表无用的数据（也许翻译人员是按翻译的文本量来收费的，这可是省成本的大好事啊）。勾选删除过期翻译项后，如果真的有过期项被删除了，你会发现翻译表里的ID分布会变得零碎。不用担心，下次刷表的时候就会重新生成ID，使得翻译项ID再次变得井然有序。

对于Text类型的字段，在生成该字段的序列化数据的时候，不再是按字符串存储数据，而是按翻译项的ID存储数据，反序列化再依据该ID从翻译表中读取对应的翻译文本。因此这样的翻译文本只是比起原生文本多占用一点点内存，比起直接用原生文本作为ID，节省更多的内存。

TODO:翻译工具还差一个功能，就是给所有在Unity预制件上的文本做翻译，因此后续应该会再增加工具收集预制件上的文本，并与现有的翻译工具配合使用。

#### 备注
项目中有测试用的Excel表，可以参考其格式
